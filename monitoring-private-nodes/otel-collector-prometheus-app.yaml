apiVersion: management.loft.sh/v1
kind: App
metadata:
  name: otel-collector-prometheus
spec:
  access:
  - users:
    - '*'
    verbs:
    - get
  config:
    chart:
      name: opentelemetry-collector
      repoURL: https://open-telemetry.github.io/opentelemetry-helm-charts
      version: 0.80.1
    values: | # yaml
      ---
      mode: daemonset
      presets:
        # Disable kubeletMetrics preset - it uses hostname
        # The prometheus receiver below scrapes kubelet metrics using InternalIP instead
        kubeletMetrics:
          enabled: false
        kubernetesAttributes:
          enabled: true
      service:
        enabled: true
      # Explicitly inject node name for local-only scraping
      extraEnvs:
        - name: K8S_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
      clusterRole:
        rules:
        - apiGroups: [""]
          resources: ["nodes", "nodes/metrics", "nodes/proxy", "services", "endpoints", "pods", "namespaces"]
          verbs: ["get", "list", "watch"]
        - apiGroups: ["apps"]
          resources: ["replicasets"]
          verbs: ["get", "list", "watch"]
        - apiGroups: ["extensions"]
          resources: ["replicasets"]
          verbs: ["get", "list", "watch"]
        - apiGroups: [""]
          resources: ["nodes/stats"]
          verbs: ["get", "list", "watch"]
        - nonResourceURLs: ["/metrics", "/metrics/cadvisor"]
          verbs: ["get"]
      config:
      {{- if and .Values.prometheus.username .Values.prometheus.password }}
        extensions:
          basicauth/prw:
            client_auth:
              username: "{{ .Values.prometheus.username }}"
              password: "{{ .Values.prometheus.password }}"
      {{- end }}
        receivers:
          # Using prometheus receiver instead of kubeletstats - it uses InternalIP and bypasses DNS
          prometheus:
            config:
              scrape_configs:
                - job_name: 'kubelet'
                  scrape_interval: 30s
                  kubernetes_sd_configs:
                    - role: node
                  scheme: https
                  tls_config:
                    insecure_skip_verify: "{{ .Values.prometheus.insecure }}"
                  authorization:
                    credentials_file: /var/run/secrets/kubernetes.io/serviceaccount/token
                  relabel_configs:
                    # Only scrape the node this pod is running on
                    - source_labels: [__meta_kubernetes_node_name]
                      regex: '${env:K8S_NODE_NAME}'
                      action: keep
                    - source_labels: [__meta_kubernetes_node_address_InternalIP]
                      target_label: __address__
                      replacement: '$$1:10250'
                    - action: labelmap
                      regex: __meta_kubernetes_node_label_(.+)
                    - source_labels: [__meta_kubernetes_node_name]
                      target_label: node

                - job_name: 'kubelet-cadvisor'
                  scrape_interval: 30s
                  kubernetes_sd_configs:
                    - role: node
                  scheme: https
                  tls_config:
                    insecure_skip_verify: "{{ .Values.prometheus.insecure }}"
                  authorization:
                    credentials_file: /var/run/secrets/kubernetes.io/serviceaccount/token
                  metrics_path: /metrics/cadvisor
                  relabel_configs:
                    # Only scrape the node this pod is running on
                    - source_labels: [__meta_kubernetes_node_name]
                      regex: '${env:K8S_NODE_NAME}'
                      action: keep
                    - source_labels: [__meta_kubernetes_node_address_InternalIP]
                      target_label: __address__
                      replacement: '$$1:10250'
                    - action: labelmap
                      regex: __meta_kubernetes_node_label_(.+)
                    - source_labels: [__meta_kubernetes_node_name]
                      target_label: node

                - job_name: 'apiserver'
                  scrape_interval: 30s
                  kubernetes_sd_configs:
                    - role: endpoints
                      namespaces:
                        names: ['default']
                  scheme: https
                  tls_config:
                    ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                    insecure_skip_verify: "{{ .Values.prometheus.insecure }}"
                  authorization:
                    credentials_file: /var/run/secrets/kubernetes.io/serviceaccount/token
                  relabel_configs:
                    - source_labels: [__meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]
                      action: keep
                      regex: kubernetes;https
        processors:
          k8sattributes:
            auth_type: 'serviceAccount'
            extract:
              metadata:
              - k8s.namespace.name
              - k8s.pod.name
              - k8s.pod.start_time
              - k8s.pod.uid
              - k8s.deployment.name
              - k8s.node.name
          transform:
            error_mode: ignore
            metric_statements:
              context: datapoint
              statements:
              - 'set(attributes["k8s.node.name"], resource.attributes["k8s.node.name"])'
              - 'set(attributes["k8s.pod.name"], resource.attributes["k8s.pod.name"])'
              - 'set(attributes["k8s.namespace.name"], resource.attributes["k8s.namespace.name"])'
          memory_limiter:
            check_interval: 1s
            limit_percentage: 75
            spike_limit_percentage: 15
          batch:
            send_batch_size: 10000
            timeout: 10s
        exporters:
          prometheusremotewrite:
            endpoint: '{{ .Values.prometheus.endpoint }}/api/v1/write'
      {{- if and .Values.prometheus.username .Values.prometheus.password }}
            auth:
              authenticator: basicauth/prw
      {{- end }}
            tls:
              insecure_skip_verify: "{{ .Values.prometheus.insecure }}"
            # Use external_labels for loft labels (simpler than attributes processor for remote write)
            external_labels:
              loft_cluster_name: "{{ .Values.loft.cluster }}"
              loft_space_name: "{{ .Values.loft.space }}"
              loft_project_name: "{{ .Values.loft.project }}"
              loft_virtualcluster_name: "{{ .Values.loft.name }}"
              loft_user_name: "{{ .Values.loft.user.name }}"
            # Disable resource to telemetry conversion to avoid duplicate labels
            resource_to_telemetry_conversion:
              enabled: false
        service:
          extensions:
          - health_check
      {{- if and .Values.prometheus.username .Values.prometheus.password }}
          - basicauth/prw
      {{- end }}
          pipelines:
            metrics:
              receivers:
              - prometheus
              processors:
              - memory_limiter
              - k8sattributes
              - transform
              - batch
              exporters:
              - prometheusremotewrite
  defaultNamespace: monitoring
  description: |
    Full OpenTelemetry Collector with Prometheus receiver for complete Kubernetes metrics coverage.
    Scrapes kubelet /metrics, cAdvisor /metrics/cadvisor, and API server /metrics endpoints.
    Use with vcluster-prv-dashboard-big.json for full metric visibility including API server metrics.
  displayName: OTEL Collector - Prometheus
  icon: https://opentelemetry.io/img/logos/opentelemetry-logo-nav.png
  parameters:
  - description: The Prometheus endpoint to push metrics to
    label: Prometheus Endpoint
    required: true
    variable: prometheus.endpoint
  - description: The Prometheus username
    label: Prometheus Username
    variable: prometheus.username
  - description: The password to access Prometheus
    label: Prometheus Password
    type: password
    variable: prometheus.password
  - description: Skip TLS verification for the connection to Prometheus
    label: Prometheus Skip TLS Verification
    type: boolean
    variable: prometheus.insecure
  recommendedApp:
  - virtualcluster
